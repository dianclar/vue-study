一、Js-api
const声明常数，里面的值不能更改。但如果是声明数组，对象等非基础数据类型对象，是建议用const声明的，原因是这种情况下声明的是指针对象，指向的是内存地址，对对象内容操作并不会影响指针值和地址。dom操作文档，Bom操作浏览器。使用document.querySelector(`css`)获取css选择器第一个dom对象，document.querySelectorAll(`css`)获取匹配的伪数组（没有数组方法）。其他获取对象方法document.getElementById获取id属性dom对象，document.getElementsByClassName获取class属性dom对象，document.getElementsByTagName获取标签dom对象。innerText获取修改dom对象值，innerHTML在此基础上可以解析标签。需要修改标签的属性就是修改dom对象下的对应属性，style属性中键的单词带连接符的换小驼峰单词，值为带单位的字符串，中间;隔开。className，clasList.add/remove/toggle修改clss属性。模板字符串``可以插入变量${}。dataset获取自己设置的data-xx方式规范的属性。函数里声明可以用const，因为函数执行完会销毁，再次调用会得到新的常量，注意函数内不要重新赋值。环境对象this指向粗略为调用着。将函数作为其他函数的参数时，该函数为回调函数。console.log方法打印信息，dir方法打印对象属性。Window.devicePixelRatio 属性为物理像素与逻辑像素比。Document.documentElement属性为html对象。setInterval设置间歇定时器，填写函数名/引号内调用函数/匿名函数，需要声明时建议使用let，clearInterval停止间歇定时器。addEventListener方法绑定事件监听，常用事件有click点击，mouseenter（建议）/over进入，mouseleave（建议）/out离开，focus聚焦，blur失焦，Keyup/down键盘，input输入，事件类型需要字符串，传递true为捕获执行，多个同事件的函数都会执行，而同on事件没有捕获且只执行最后赋值的函数。事件函数的第一个参数为事件对象event，type属性为事件类型，clientX/Y属性为光标的窗口位置，offsetX/Y属性为光标的dom元素位置，key/Code属性为键盘值。事件流分为捕获从大到小和冒泡从小到大阶段，触发事件会传递执行所有父子元素事件函数，事件对象stopPropagation方法阻止事件传递，stopPropagation方法阻止默认行为。removeEventListener方法解除非匿名函数事件，on事件赋空解除。可以利用事件流实现事件委托，给父元素绑定事件，子元素事件冒泡触发父元素事件，事件对象target属性为子元素对象。load事件为资源加载完成，DOMContentLoaded事件为文档加载完成，scroll事件为页面滚动，resize事件为窗口更改。scrollTop/Left属性为卷去的垂直/水平位置，可赋值，值为数字不带单位，offsetTop/Left属性为相对已定位父元素的垂直/水平位置。clientWidth/Height属性为可见宽高，offsetWidth/Height属性为边框宽高。new Date方法实例化日期对象，参数可以为字符串指定时间，getFullYear()方法获取4位年份，getMonth()方法获取月份-1，getDate()获取与月有关的天，getDay()获取星期（0为星期天），getHours()获取时，getMinutes()获取分，getSeconds()获取秒, toLocale/Date/TimeString方法获取格式化时间，getTime方法获取时间戳。+new Date/.now方法获取时间戳。Dom树的每一个内容为Dom节点，有元素节点，属性节点，文本节点。parentNode属性获取父节点，childNodes获取子节点的伪数组，next/previousElementSibling获取上下兄弟节点。Document.createElement方法创建节点，cloneNode方法克隆节点，传入true同时克隆子节点，appendChild方法将节点追加到父元素末尾，insertBefore方法插入父元素里某元素前面，配合childNodes[0]可以插入到首位。removeChild方法删除父元素下的节点，与隐藏节点节点还在不同。声明函数时后面跟(*);可以立即执行函数，非箭头函数可以前面加运算符来让函数识别为整体。touchstart事件为触摸，touchmove事件为滑入，touchend事件为移开。要使用插件，先下载，然后在页面引入css和js。Window对象包含document和navigation，location，history等。setTimeout方法设置延时定时器，clearTimeout方法结束延时定时器。浏览器有俩大引擎，一个渲染器，一个js解释器。Js为单线程，为了解决单线程问题出现了同步和异步，同步为顺序执行，在主线程执行，形成执行栈，异步为条件满足执行，分宏任务和微任务。Js执行机制为先执行同步任务，微任务满足后加入微任务队列，宏任务交给宿主环境，满足加入宏任务队列，同步执行完成后读取微任务，宏任务，并加入执行栈执行，如此循环称为事件循环。Location对象保存拆分链接，href属性为访问链接，可赋值跳转页面，search属性为链接携带参数，hash属性为链接哈希值，是spa页面路由#基础，reload方法可以刷新页面，传true可以强制刷新。Navigation对象保存浏览器信息，userAgent属性为浏览器版本平台等信息。History对象保存层级信息，back方法可以后退页面，forward方法可以前进页面，go方法可以前进后退页面。localStorage对象可以把数据以键值对储存到本地，多窗口共享，setItem方法储存/修改数据，getItem方法读取数据，removeItem方法删除数据。SessionStorage对象可以把数据以键值对暂时保存，单窗口共享，关闭浏览器结束，常用方法与localStorage相同。本地储存只能字符串，复杂数据可以JSON.Stringify方法转json字符串储存，读取后parse方法转回来。数组对象map方法可以遍历数组并返回新数组，回调函数有e，i俩参数，相对于forEach有返回值，join方法可以将数组转字符串，参数传入字符可以指定分割元素的字符。test/exec方法可以判断字符串是否匹配正则表达式，replace方法替换匹配的字符串。边界符^*匹配行首字符，*$匹配行尾字符，^*$为精确匹配。量词*重复次数不限，+重复至少一次，?重复最多一次，{*}重复指定次数，{*,}重复至少指定次数，{*,*}重复最多至少指定次数。字符[***/*-**-*]匹配字符集合，[^*]匹配排除字符集合，.匹配排除换行的字符，*|*匹配其中一个正则，\d匹配数字，\D匹配排除数字，\w/\W匹配/排除数字字母下划线， \s/\S匹配/排除空字符。修饰符i不区分大小写，g所有匹配结果。

二、Es6+
局部作用域分为函数作用域和块作用域，参数与函数内声明的变量可以在函数内使用，外部不能直接使用，函数执行结束，函数作用域变量清空。js{}内的代码为代码块，块内非var声明的变量产生块作用域，外部不能直接使用。全局作用域的变量可以被其他作用域使用，但应该尽可能少声明全局变量避免全局变量污染。作用域链为底层查找机制，全局和局部可以有同一个变量，函数执行时优先查找当前作用域变量，然后逐级查找父级作用域至全局作用域。Js的内存分配回收自动完成，变量不在使用时自动回收内存，一般全局变量不会自动回收，在关闭页面时回收。内存因为某原因无法回收，称为内存泄漏。浏览器有俩回收算法，为引用计数法和标记清除法。引用计数法在对象没有指向的引用时回收，但在堆内嵌套引用时无法回收。标记清除法从全局对象开始往下查找，能查找到的标记，没有标记的回收。内层函数访问外层函数变量构成闭包，如果闭包时执行外层函数会返回内层函数，那外部通过返回的内层函数可以访问外层函数变量，且变量不会被回收，可能造成内存泄漏。Var声明的变量会变量提升，被提取到作用域代码最前面，但只提升声明，不赋值，所以可以先使用，在声明，非箭头函数也有提升。非箭头函数的动态参数可以不设形参，通过arguments获得实参伪数组。函数可以通过剩余参数...*作为形参，将实参数组赋值给*，可以同时设普通参数，但需要设置到前面。...数组为展开运算符，可以将数组元素提取出来。箭头函数在形参只有一个的时候可以省略()，代码块只有一行时可以省略{}和return，可以直接返回被括号括起来的对象，this沿用父级作用域this，所以不建议在dom事件，原型中使用箭头函数。数组解构;[*]=arr可以将数组元素同时赋值给不同形参，比元素多的形参不会赋值，可以设置默认值，变量少时也可以使用剩余参数，可以空形参忽略对应元素，可以解构多维数组。对象解构{}=可以将对象属性方法同时赋值给与属性方法名相同形参，形参可以通过:改名，可以和数组解构一起解构对象数组，解构对象里的对象需要使用对象名:{}解构。在函数形参中也可以使用解构，箭头函数时形参需带括号。数组forEach方法可以遍历数组元素，索引并传递给回调函数，没有返回值，适合在对象数组使用。构造函数可以批量创建类似对象，缺点浪费内存，声明时建议以大写字母开头，使用new实例化，实例化的对象是不同的对象，互不影响，构造函数的属性方法为静态成员，常用的内置构造函数有Object，Array，String，Number，js的基本数据类型都有构造函数，称为包装类型。Object常用静态方法，keys/values方法可以得到对象所有键/值的数组，assign方法可以拷贝对象，可以用于给对象添加属性。数组reduce方法可以返回累计处理结果，给回调函数处理值和当前值俩实参，可以传初始处理值。Array.from方法可以把伪数组转数组。JavaScript 是一种多范式编程语言，通过构造函数和原型实现面向对象。构造函数的prototype属性为原型对象， this指向实例化对象，constructor属性为构造函数，可以定义方法让对象实例共享方法，赋值实例化对象来继承构造函数，通过原型实现继承为原型继承， __proto__ 属性指向上级原型对象，形成原型链，instanceof运算符判断是否在原型链上。实例对象 __proto   属性为对象原型，指向原型对象，不能赋值。函数内部调用自己形成递归，容易内存栈溢出，建议有 return。Forin的实参在处理对象时是键，数组时是索引。对象.属性可以写为对象[属性]来处理变量当属性名。拷贝针对引用类型，浅拷贝只拷基础数据和引用地址，深拷贝的对象不会影响旧对象，可以用递归函数，调用库，转json字符串实现。throw_new_Error方法可以抛出自定义错误信息，终止程序，try尝试执行，catch捕获异常，不终止程序，finally在error时也继续执行。debugger定位代码位置。以下方法指定this指向，call方法，apply方法，需要传数组，bind方法，不会执行函数，返回拷贝函数。防抖是一段时间内不再次触发执行，节流是一段时间内只执行一次。

三、Ajax
Ajax是XMLHttpRequest对象，负责与服务器通信，常用基于Ajax，Promise的axios库。Axios引入后获得axios函数，基本语法axios({url，method，data{}，params{}}).then(d=>{}).catch(e=>{})。url是统一资源定位符，简称网址，由协议，域名，路径，参数等组成，参数格式为?*=*&。http协议是超文本传输协议，请求方法一般有get，post，put，delete，patch等，请求/响应报文包含请求/响应行，请求/响应头，空行，请求/响应体，响应状态码有1**信息，2**成功，3**重定向，4**客户端错误，5**服务器错误。文件上传，input-file的事件对象的target./files属性为文件对象，new FormData实例化表单数据对象，append方法添加文件对象，上传表单数据对象。new XMLHttpRequest方法实例化ajax对象，open方法配置请求方法和url，loadend事件接收响应，send方法发起请求，可以传数据，setRequestHeader('Content-Type', 'application/json')设置请求头。new Promise ((resolve,reject)=>{})实例化对象，默认为pending状态，resolve方法改为fulfilled状态，触发并传参给.then方法回调，reject方法改为rejected状态，触发并传递给catch方法，.then方法return Promise为链式调用，避免嵌套，all静态方法可以接收多Promise状态，参数接收Promise对象数组，返回参数数组。回调嵌回调多次为回调地狱，耦合高，可读查，捕错难。async，await是Promise的语法糖，async关键字声明的函数内允许使用await，await取代then接收Promise状态并返回参数，捕错用try。new URLSearchParams方法接收对象实例化url参数对象，toString方法转参数字符串。

四、Ts
ts是js的超集，ts=type+js，ts是静态类型编程语言，编译时做类型检查。安装编译器：npm i -g typescript，编译命令：tsc *.js，执行命令：node *.js，安装简化编译运行器：npm i -g ts-node，简化编译运行命令：ts-node *.js。类型注解：var a:number=0中:*即为类型注解，为变量添加类型约束，只能赋值约束的类型，否则报错。ts新增类型：联合类型、类型别名、接口、元组、字面量、枚举、void、any等。数组：var a:number[]=[];var a:Array<string>=[]中:*[]或Array<*>即为数组类型，多类型数组可以写:(*|*)[]，与:*|*[]含义不同，|为联合类型，表示多类型的一种。类型别名：type a=number|string中tpye*=*即为类型别名，后面可以使用别名作为类型注解。函数：function a(b:number):void{};const a=(b:number):void=>{};const a:(b:number)=>void=(b)=>{}中function或=>或:(*:*)=>*即为函数类型，需为参数、返回值作类型注解，有返回值一般有return，没有返回值为void。可选参数：const a=(b?:number):void=>{}中?:*即为可选参数，表示可以没有的参数，需在其他参数后面。对象：var a:{b:number;c():void;d?:()=>void}={}中:{*:*}即为对象类型，也可以带可选参数。接口：interface a{b():void}中interface*{}即为接口类型，在同对象类型多次使用时可以声明接口来复用，后面可以使用接口作为类型注解，注意和类型别名区分。可以使用extends继承其他接口。元组：var a:[number,string]=[]中:[*]即为元组类型，需知道元素的个数和类型。类型推论：在未类型注解时，ts自动注解即为类型推论，常在声明变量并赋值或注解函数返回值时自动注解。类型断言：a as b;<a>b中使用*as*或<*>*即为类型断言，需为父子类型或联合交叉类型，否则报错，使用console.dir方法查看原型链可以知道元素类型。字面量：const a=0中类型为常量即为字面量类型，可以配合联合类型实现枚举的功能并更高效。枚举：enum A{B=39}中使用enum*{}即为枚举类型，建议名称与值大写开头，使用.访问枚举成员，枚举值默认从0自增，可以声明时用=给成员自定义默认值，非数字枚举需自定义值，后面可以使用枚举作为类型注解。any：var a;var a=(b)=>{}中参数或未赋值变量未类型注解即为any类型，取消类型保护，可以对值任意操作，应尽量避免，仅临时使用。ts中typeof关键字可以使用在类型注解中，将其他对象的类型作为类型注解，不能获取函数返回值。class类：class a{b:number;c='0'}中以class*{}即为类类型，使用new关键字实例化类对象，可以设置默认值，constructor方法构造函数，返回值不能类型注解，extends关键字继承父类，ts中可以使用implements关键字实现接口，public/protected/private关键字控制访问性，readonly关键字表示属性只读，只能在构造函数中赋值，需类型注解，可以使用在接口对象。ts使用结构化类型系统（Structural Type System），名称不同但有相同结构的俩个对象认为是兼容的，接口和类少兼多，也可以互相兼容，函数参数数量类型多兼少，返回值少兼多，回调函数参数会自动注解。交叉类型：a&b中*&*即为交叉类型，功能类似继承，但对重名属性方法有不同的处理逻辑。泛型：function a<T>(b:T):T{}中*<*>即为泛型，里面的值为类型变量，extends关键字泛型约束，keyof关键字获取对象键的联合类型，泛型工具Partial<T>创建属性可选的类型，Readonly<T>创建属性只读的类型，Pick<T,K>创建T的K属性的类型，Record<K,T>创建K键T值的类型。索引签名：{[a:string]:number}中[*:*]即为索引签名类型，js中对象键是字符串类型，数组是特殊对象，键为数字类型。映射：type a{[key in keyof b]:number}中[*in*]即为映射类型，只能在类型别名中使用。索引访问：a[b|keyof c]中*[*]即为访问索引类型，表示属性的类型。类型声明文件.d.ts为js库提供类型信息，不含可执行代码不会编译成js，ts已为js标准api提供类型声明文件，大部分第三方库可以使用npm i @types/*命令下载类型声明文件，declare关键字为js文件已有变量声明类型。命名导出：export var a=0;中export*即为命名导出，可导出多个，import关键字导入，需带{}并写明哪几个。默认导出：export default a中export default*即为默认导出，不能导出声明，只能导出一个，import关键字导入，无需带{}，名称可自定义，可与命名导出混用。

五、Git
git init初始化本地仓库，git config --global user.name "Your Name";git config --global user.email "your@email.com"全局配置，git add .  工作区保存至暂存，git commit -m "message"   提交更新并注释，git remote add origin <url>  添加远程仓库，git clone <url>  克隆远程仓库，git pull origin <branch>  拉取并合并远程分支，git push origin *  推送本地分支到远程后续git push即可，git log  基础日志，git reset --hard <commit>  强制回退到指定版本取消暂存git reset即可，README.md配置说明文件，.gitignore配置忽略文件*.*文件*/文件夹。

六、Node
Node.js是跨平台js运行环境，可以搭建服务器端js程序，编写数据接口，前端工程化，基于v8引擎，node环境没有bom，dom，ajax，使用node *.js命令执行js文件。终端快捷↑上一条命令，tab补全路径，esc清空命令，cls清空终端，ctrl+c停止服务，ctrl+shift+`vsc新建终端。commonJS标准导出module.exports={}，导入require('*')。fs读写文件模块，writeFile方法写入文件，参数1必选路径字符串，参数2必选写入内容，参数3可选格式，不能创建路径，覆盖之前内容，readFile方法读取文件，参数1必选路径字符串，参数2可选编码格式，参数3必选回调函数。绝对路径以终端为起点而非文件，建议使用绝对路径，__dirname变量获取目录绝对路径。path路径处理模块，join方法拼接路径，basename方法获取路径的文件名，extname方法获取路径的扩展名。端口号标记不同功能的服务程序，值0-65535，访问时默认80，localhost/127.0.0.1代表本机域名ip。http服务器模块，createService方法得到web服务对象，on方法监听request请求，req请求对象，url属性请求的地址，method属性请求方式，res响应对象，setheader设置响应头，end方法设置响应体并结束响应，listen方法启动，设置端口，执行回调。模块化提高代码复用性，可维护性，并能按需加载，模块分内置模块fs，path，http，自定义模块.js，第三方模块，使用require时会执行模块代码，导入自定义模块可省略.js，模块作用域是变量函数只能在模块内访问，module对象储存模块信息，exports对象导出模块成员，第三方模块称为包。npm是软件包管理器，npm init -y初始化并获得package.json文件，npm i安装依赖，i *下载包，@*下载指定版本，-g安装到全局，-D安装到开发，uni*删除包，npm config set registry=https://registry.npmmirror.com指定源。包分为项目包，全局包，项目包分开发包，核心包。项目包在项目中使用，下载到node_modules中，并在packagelock文件储存信息，git需在.gitignore忽略node_modules，全局包所有项目使用。package是包管理配置文件，dependencies键保存下载的包，devDependencies键为开发包。包结构规范，以一个目录包含，顶级目录下带package文件，键有name名称，version版本，main入口，可以带description描述，author作者，keywords搜索关键字，license许可协议，可以包含README.md文件，说明安装方式，导入，功能，协议等，版本规范为三位点分十进制，一位大版本，二位功能版本，三位debug版本，前增加，后归零。开发包，创建文件夹根目录，根目录创建package.json并配置，index.js当入口文件，README.md并写说明，src文件夹，把功能分开写到src文件夹js文件中并导出，在index.js导入导出，注册npm账号，切官方源，npm login登录，npm publish发布，npm unpublish * --force删除72h内包。模块加载后缓存，多次require只执行一次，内置模块优先级最高，自定义模块要路径，查找文件名-.js-.json-.node，包查找package的main-index.js。

express框架包可以快速搭建web服务器，api服务器，express方法获取web服务器，listen方法启动，设置端口，执行回调，get方法监听get请求，post方法监听post请求，send方法响应请求，req.query方法获取url参数，params方法获取动态参数/:a，安装nodemon包并使用nodemon *.js命令可以修改代码后自动重启服务器，router方法创建路由对象，use方法注册中间件，express.static中间件创建资源服务器，json中间件解析json请求体，urlencoded中间件解析urlencoded请求体，中间件会对请求预处理，可以使用错误中间件捕获错误，需要注册在其他中间件后面，第三方中间件body-parser包可以解析请求体，数据大的时候，客户端会触发多次data分批发送数据，完成触发end，内置querystring模块可以处理字符串，parse方法解析为对象，编写接口一般为send({status:0,msg:'成功',data:*})，第三方中间件cors包可以解决接口跨域问题，Access-Control-Allow-Origin响应头指定允许访问此资源的域，Headers响应头声明额外请求体信息，Methods响应头声明额外请求方式，jsonp是通过script src请求并接收函数调用，仅支持get。mysql包可以连接操作MySQL数据库，createPool({host:'',user:'',password:'',database:''})方法配置并获得mysql数据库对象，query方法执行sql语句并执行接收结果参数回调，sql语句可以使用?占位符，后续第二个参数里的值赋值给?，通过设置字段表示删除状态，然后使用更新状态模拟删除。web开发模式分服务器端渲染，服务器动态生成html响应，前端性能好，利于seo，前后端分离，服务器提供api接口，开发/用户体验好，减轻服务器压力。cookie可以突破无状态，是储存于浏览器的4kb字符串，由一个键值对和其他可选属性组成，请求时自动发送，域名独立，不具有安全性。中间件express-session包可以使用session认证，session({secret:'*',resave:false,saveUninitialized:true})配置并要在use方法中注册，后续通过请求对象session属性访问对象，destroy方法清除session信息。token是加密信息的字符串，通过authorization请求体发给服务器，jwt分header，payload，signature，需要jsonwebtoken和express-jwt包，定义secret密钥，jsonwebtoken.sign方法生成jwt字符串，express-jwt({secret:*}）unless({path:[*]})配置中间件排除解析，请求对象user属性获取jwt解析信息，token不要加密密码。

webpack包是静态打包工具，可以完成把html，css，js，资源等内容进行压缩，整合，转译等前端工程化工作，npm i webpack webpack-cli --save-dev命令下载，需在package文件的script键加值"*":"webpack"，后续通过npm run*命令打包。在根目录创建webpack.config.js文件可以配置打包出入口，和清空目录。webpack的插件下载后在webpack.config.js文件require引入并在plugins键注册使用，加载器在module键注册使用。html-webpack-plugin包插件可以打包时生成html，css-loader包加载器可以解析css代码，style-loader包加载器可以插入dom，mini-css-extract插件可以提取css代码，不能和style-loader一起使用，less-loader包加载器可以把less代码编译成css代码，。webpack.config.js文件mode键配置打包模式，resolve键alias键可以配置src路径为@，建议配置cdn加载。

七、MySql
数据库是储存管理数据的仓库，MySQL是一个开源免费流行的数据库，一般每个项目对应独立数据库，不同数据存于不同表。开发一般安装server和workbench，server储存管理数据，workbench可视化管理。mysql -u * -p连接mysql3306端口，SHOW DATABASES;显示所有数据库，CREATE DATABASE *创建数据库，DROP DATABASE*删除数据库，USE*切换数据库，SELECT DATABASE()查看当前使用的数据库，SHOW TABLES;，DESC*查看表结构，CREATE TABLE * (* * *）创建表，DROP TABLE*删除表，ALTER TABLE * RENAME TO *修改表名，ALTER TABLE * ADD * *添加列，ALTER TABLE * DROP COLUMN *删除列，INSERT INTO 表名 (列1, 列2) VALUES (值1, 值2);插入数据，SELECT * FROM 表名; -- 查询所有列，SELECT 列1, 列2 FROM 表名 WHERE 条件;查询数据，UPDATE 表名 SET 列名=新值 WHERE 条件;更新数据，DELETE FROM 表名 WHERE 条件;删除数据，TRUNCATE TABLE 表名;清空表数据。sql是结构化查询语言，是访问和处理数据库的编程语言，用sql编写的代码称为sql语句，在关系型数据库sql中使用。-- 为注释，关键字对大小写不敏感。order by*可以升序，sesc降序，count(*)给出数量。